# -*- coding: utf-8 -*-
"""Modulaciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vyIY597lifFJ3SCMQIRfqpgttXHsfq0R
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.fftpack as fourier

"""# Modulación AM

## c)
"""

fig, axs = plt.subplots(3, 1, figsize=(8, 7), tight_layout = True)

fm = 50
Am = 2

u = 1
Ka = u/Am

fc = 10*fm
Ac = 1

t = np.arange(-0.1, 0.1, 1/(10*fc))
f_port = Ac*np.cos(2*np.pi*fc*t)
f_mensaje = Am*np.cos(2*np.pi*fm*t) 
f_modulada = (1 + Ka*f_mensaje)*f_port 
axs[0].plot(t, f_mensaje, c = 'navy')
axs[0].set_ylabel('Amplitud')
axs[0].set_xlabel('Tiempo (s)')
axs[1].plot(t, f_port, c = 'red')
axs[1].set_xlabel('Tiempo (s)')
axs[1].set_ylabel('Amplitud')
axs[2].plot(t, f_modulada, c = 'purple')
axs[2].set_xlabel('Tiempo (s)')
axs[2].set_ylabel('Amplitud')
axs[0].set_title(f'Señal mensaje')
axs[1].set_title(f'Señal portadora')
axs[2].set_title(f'Señal modulada con \u03BC = {u}')
#plt.savefig(f'Indice {u}.jpg', dpi  = 100)

"""## d)"""

fig, axs = plt.subplots(3, 1, figsize=(7, 7), tight_layout = True)

op = 1 ## 1 PARA VER SEÑAL TEMPORAL; 2 PARA ESPECTRO EN MAGNITUD; 3 PARA ESPECTRO EN FASE
us = [0.3, 0.8, 1.5] ##SELECCIONE LOS 3 valores

choices = ['Señal', 'Magnitud', 'Fase']
for i in range(0, 3):
    fm = 50
    Am = 1
    u = us[i]
    Ka = u/Am
    fc = 10*fm
    Ac = 1 
    t = np.arange(-0.1, 0.1, 1/(10*fc))
    f_port = Ac*np.cos(2*np.pi*fc*t)
    f_mensaje = np.cos(2*np.pi*fm*t) 
    f_modulada = (1 + Ka*Am*f_mensaje)*f_port
    if op == 0:
        axs[0].set_title('Señal modulada para distintos valores de \u03BC')
        axs[i].plot(f_modulada,  c = 'purple', label = f'\u03BC = {u}')
        axs[i].legend(loc = 'upper right')
        axs[i].set_xlabel('Tiempo (s)')
        axs[i].set_ylabel('Amplitud')
    elif op == 1:
        Ts = t[2] - t[1]
        Fs = 1/Ts
        trans_fourier = np.fft.fft(f_modulada)
        trans_fourier_2 = np.fft.fftshift(trans_fourier)
        espectro = abs(trans_fourier_2)
        frq = np.arange(-Fs/2, Fs/2, Fs/len(f_modulada))
        axs[0].set_title('Espectro en magnitud de la señal para distintos valores de \u03BC')
        axs[i].plot(frq, espectro, c = 'red', label = f'\u03BC = {u}')
        axs[i].legend(loc = 'upper right')
        axs[i].set_ylabel('Amplitud FFT')
        axs[i].set_xlabel('Frencuencia (Hz)')
    else:
        Ts = t[2] - t[1]
        Fs = 1/Ts
        axs[0].set_title('Espectro en fase de la señal para distintos valores de \u03BC')
        axs[i].phase_spectrum(f_modulada, Fs = Fs, color ='mediumblue', label = f'\u03BC = {u}')
        axs[i].legend(loc = 'upper right')
        axs[i].set_ylabel('Fase (radianes)')
        axs[i].set_xlabel('Frencuencia (Hz)')
#plt.savefig(f'{choices[op]}.jpg', dpi  = 100)

"""## e)"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook
fig, axs = plt.subplots(2, 1, figsize=(8, 7), tight_layout = True)

fm = 50
Am = 2

u = 0.99
Ka = u/Am

fc = 10*fm
Ac = 1

t = np.arange(-0.1, 0.1, 1/(10*fc))
f_port = Ac*np.cos(2*np.pi*fc*t)
f_mensaje = Am*np.cos(2*np.pi*fm*t) 
f_modulada = (1 + Ka*f_mensaje)*f_port 
axs[0].plot(t, f_mensaje, c = 'navy')
axs[0].set_ylabel('Amplitud')
axs[0].set_xlabel('Tiempo (s)')
axs[1].plot(t, f_modulada, c = 'purple')
axs[1].set_xlabel('Tiempo (s)')
axs[1].set_ylabel('Amplitud')
axs[0].set_title(f'Señal mensaje')
axs[1].set_title(f'Señal modulada con \u03BC = {u}')
#plt.savefig(f'Indice {u}.jpg', dpi  = 100)

"""## g)"""

fig, axs = plt.subplots(3, 1, figsize = (6, 6))
a = len(espectro)
espectro_pre_positiva = np.r_[np.zeros(500), 2*espectro[a//2:]]
pre_positiva = np.fft.ifft(espectro_pre_positiva)
env_compleja = pre_positiva*np.exp(-1j*2*np.pi*fc*t)
env_natural = abs(env_compleja)

#Espectro envolvente compleja
env_compleja_tf = np.fft.fft(env_compleja)
espectro_env_compleja = abs(env_compleja_tf)

axs[0].plot(frq, espectro_pre_positiva, color = 'r')
axs[1].plot(frq, espectro_env_compleja)
axs[2].plot(t, env_natural, color = 'navy')

"""# Modulación FM"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook

fig, ax = plt.subplots(2, 2, figsize=(9, 6))
t = np.linspace(-1, 4, 1000)
fc = 5000
fm = 500
bheta = 50
y = np.cos(2*np.pi*fc*t + bheta*np.sin(2*np.pi*fm*t))
y2 = np.exp(1j*bheta*np.sin(2*np.pi*fm*t))
autocorr  = np.correlate(y, y, mode = 'full')/(len(y)*np.var(y))
autocorr2  = np.correlate(y2, y2, mode = 'full')/(len(y2)*np.var(y2))

b = len(autocorr)
ax[0, 0].plot(t, y, 'navy')
ax[0, 1].plot(t, autocorr[b//2:], 'red')
ax[1, 0].plot(t, y2, 'navy')
ax[1, 1].plot(t, autocorr2[b//2:], 'red')











